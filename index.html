<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <title>GLTF Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  //Import modules
  //import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
  //import { GLTFLoader } from './GLTFLoader.js';
  //import { OrbitControls } from './OrbitControls.js';
  //import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
  import * as THREE from './js/three.module.js';
  import { GLTFLoader } from './js/GLTFLoader.js';
  import { DRACOLoader } from './js/DRACOLoader.js';
  import { OrbitControls } from './js/OrbitControls.js';
  //import { parseNPZ } from './libs/main.js';

  const loader = new GLTFLoader();

  const dracoLoader = new DRACOLoader();
  // Point this to the Draco decoder files (downloaded from three.js repo)
  dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/'); 
  // or a local path like './draco/' if you host the decoder files yourself

loader.setDRACOLoader(dracoLoader);
  // renderer , camera, scene, controls
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const aspect = window.innerWidth / window.innerHeight;
  const frustumSize = 100000; // adjust to cover your scene extents

  const camera = new THREE.OrthographicCamera(
  -frustumSize * aspect / 2,  // left
   frustumSize * aspect / 2,  // right
   frustumSize / 2,           // top
  -frustumSize / 2,           // bottom
   1,                         // near
   200000                     // far
);

 
  //const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 120000);

  // Lighting section â€” right after camera
  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  
  const hemi = new THREE.HemisphereLight(0x88ccff, 0x222244, 0.8);
  scene.add(hemi);
   
  const directional = new THREE.DirectionalLight(0xffffff, 0.2);
  directional.position.set(1, 1, 1);
  scene.add(directional);
    
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  console.log('Attempting to load GLTF...');
  
  // Create a UI container
    const ui = document.createElement('div');
    ui.style.position = 'absolute';
    ui.style.top = '10px';
    ui.style.left = '10px';
    ui.style.background = 'rgba(0,0,0,0.7)';
    ui.style.padding = '10px';
    ui.style.color = 'white';
    ui.style.fontFamily = 'sans-serif';
    ui.style.zIndex = '10';
    document.body.appendChild(ui);
  
  // Functions and helpers
  
  // Create axis label sprites
  function createAxisLabel_old(text, position, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = '24px sans-serif';
      context.fillStyle = 'white';
      context.fillText(text, 0, 24);
    
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, color });
      const sprite = new THREE.Sprite(material);
      sprite.position.copy(position);
      sprite.scale.set(100, 50, 1);
      return sprite;
  }
     
  function createAxisLabelMesh(text, position, rotation, color = 0xffffff) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
    
      const context = canvas.getContext('2d');
      context.font = '28px sans-serif';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, canvas.width / 2, canvas.height / 2);
    
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        color,
  });
    
      const geometry = new THREE.PlaneGeometry(100, 40);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.rotation.set(rotation.x, rotation.y, rotation.z);
      return mesh;
  }
  
  const subgroupStates = {
      AllSystems: true,
      Criteria: true,
      IceCrystal: true,
      SilicateCrystal: true,
      PodTrees: true,
      PodSystems: true
  };  
  
  let activeState = 'before'; // default

  //set up import of model 
  let meshList = [];
  let sphereMesh = []; // ðŸ‘ˆ this will hold meshList[13] once loaded
  let before_allSystems = [];
  let after_allSystems = [];
  let  He_mass_code_0 = [];
  let  He_mass_code_1 = [];
  let  He_mass_code_2 = [];
  let  He_mass_code_3 = [];
  let  He_mass_code_4 = [];
  let  He_mass_code_5 = [];
  let  He_mass_code_6 = [];
  let  He_mass_code_7 = [];
  let guardian_ruins = [];
  let guardian_structures = [];
  let guardian_beacons = [];
  
  // load the gtlf file 
  // const loader = new GLTFLoader();
  loader.load('https://precambrianmollusc.github.io/Glaxy_vis_test/galaxy_optimized.glb', (gltf) => {
    const model = gltf.scene;
    scene.add(model);
    console.log('GLTF loaded:', model);

  model.traverse(obj => {
    if (obj.isMesh || obj.isLine || obj.isPoints) {
      const mat = obj.material;
      const geom = obj.geometry;

      console.log(`Object: ${obj.name || '(unnamed)'}`, {
        type: obj.type,
        materialType: mat?.type,
        color: mat?.color ? mat.color.getHexString() : 'n/a',
        transparent: mat?.transparent,
        opacity: mat?.opacity,
        vertexColors: mat?.vertexColors,
        geometryAttributes: Object.keys(geom.attributes),
      });

      // If vertex colors exist, log their itemSize (3=RGB, 4=RGBA)
      if (geom.attributes.color) {
        console.log(`  â†³ vertex color itemSize: ${geom.attributes.color.itemSize}`);
      }
    }
  });

    console.log('Total meshes found:', meshList.length);
    // fix red for the high He meshes 
    
    //model.traverse(obj => {
    //  if (obj.isMesh && obj.material && obj.material.color) {
    //    const c = obj.material.color;
    //    // crude "is red" check: R much higher than G/B
    //    if (c.r > 0.6 && c.g < 0.3 && c.b < 0.3) {
    //      obj.material.emissive = c.clone(); // match base color
    //      obj.material.emissiveIntensity = 0.6; // default, will be sliderâ€‘controlled
     //     obj.material.needsUpdate = true;
    //      console.log(`ðŸ”§ Applied emissive to ${obj.name}`);
    //    }
    //  }
   // });


    
    // 3. Grouping/naming
  model.traverse(child => {
    if (child.isMesh || child.type === 'Points') {
      meshList.push(child);

      switch (child.name) {
        case 'mesh0': He_mass_code_0.push(child); break;
        case 'mesh1': He_mass_code_1.push(child); break;
        case 'mesh2': He_mass_code_2.push(child); break;
        case 'mesh3': He_mass_code_3.push(child); break;
        case 'mesh4': He_mass_code_4.push(child); break;
        case 'mesh5': He_mass_code_5.push(child); break;
        case 'mesh6': He_mass_code_6.push(child); break;
        //case 'mesh7': He_mass_code_7.push(child); break;
        case 'mesh7': guardian_ruins.push(child); break;
        case 'mesh8': guardian_structures.push(child); break;
        case 'mesh9': guardian_beacons.push(child); break;  
        case 'mesh10': sphereMesh = child; break;
      }

      console.log(`Mesh ${meshList.length - 1}:`, child.name || '(unnamed)');
    }
  });

// Create a parent group for all He_mass_code_x meshes
const He_mass_group = new THREE.Group();
He_mass_group.name = "He_mass_group";

// Add all the He_mass_code_x arrays into the group
[
  He_mass_code_0,
  He_mass_code_1,
  He_mass_code_2,
  He_mass_code_3,
  He_mass_code_4,
  He_mass_code_5,
  He_mass_code_6
  //He_mass_code_7
].forEach(arr => {
  arr.forEach(mesh => He_mass_group.add(mesh));
});

// After youâ€™ve added all meshes into He_mass_group
He_mass_group.traverse(obj => {
  if (obj.isMesh && obj.geometry && obj.geometry.attributes.color) {
    const colors = obj.geometry.attributes.color;
    const orig = new Float32Array(colors.count * 3);

    // Copy normalized RGB values (already 0â€“1 in Three.js)
    for (let i = 0; i < colors.count; i++) {
      orig[i*3]   = colors.getX(i);
      orig[i*3+1] = colors.getY(i);
      orig[i*3+2] = colors.getZ(i);
    }

    // Store once on the mesh
    obj.userData.originalColors = orig;

    // Debug: log the first cached vertex color
    if (orig.length >= 3) {
      console.log('Cached normalized first color:',
        orig[0].toFixed(3), orig[1].toFixed(3), orig[2].toFixed(3));
    }
  }
});


    
// Add the group to the scene
scene.add(He_mass_group);
    


    // set up the meshes in groups 
    // BEFORE meshes
    const beforeMeshes = {
      AllSystems: [before_allSystems]
      };
    
    // AFTER meshes
    const afterMeshes = {
      AllSystems: [after_allSystems]
      };

    // somewhere after you create groups
    const groupObjects = {
      HeMassGroup: He_mass_group,
      // add more groups here if needed
    };
    

    
    // set up the sphere for the Hen nebula 
    sphereMesh.material.opacity = 0.3;
    sphereMesh.material.transparent = true;
    sphereMesh.material.depthWrite = false;
    sphereMesh.material.needsUpdate = true;

    // point cloud for all beforesystems - should be a low opacity blur
    //before_allSystems.material.size = 2.0; // make points larger
    //before_allSystems.material.opacity = 0.3;
    //before_allSystems.material.transparent = true;
    //before_allSystems.material.needsUpdate = true;

    // point cloud for all after systems - should be a low opacity blur
    //after_allSystems.material.size = 2.0; // make points larger
    //after_allSystems.material.opacity = 0.3;
    //after_allSystems.material.transparent = true;
    //after_allSystems.material.needsUpdate = true;
  
    // point cloud for the systems that meet criteria but no SPS  we will make this look like spheres
    const sprite_sphere = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    sprite_sphere.colorSpace = THREE.SRGBColorSpace; // ensures correct color rendering
    console.log('Sprite loaded:', sprite_sphere);

    //before_criteria.material.map = sprite_sphere;
    //before_criteria.material.size = 10;
    //before_criteria.material.opacity = 0.7;
    //before_criteria.material.transparent = true;
    //before_criteria.material.depthWrite = false; // prevents z-fighting
    //before_criteria.material.needsUpdate = true;
    //before_criteria.material.blending = THREE.AdditiveBlending;
    
    //after_criteria.material.map = sprite_sphere;
    //after_criteria.material.size = 10;
    //after_criteria.material.opacity = 0.7;
    //after_criteria.material.transparent = true;
    //after_criteria.material.depthWrite = false; // prevents z-fighting
    //after_criteria.material.needsUpdate = true;
    //after_criteria.material.blending = THREE.AdditiveBlending;

    // set up the sphere for the raduis of NSPs from the center 
    //sphereMesh.material.opacity = 0.3;
    //sphereMesh.material.transparent = true;
    //sphereMesh.material.depthWrite = false;
    //sphereMesh.material.needsUpdate = true;
   
  // add the bounding box 
          //const box = new THREE.Box3().setFromObject(model);
          const box = new THREE.Box3().setFromObject(He_mass_group);

          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());
          console.log('Bounding box size:', size);
          console.log('Bounding box center:', center);
      
          camera.position.set(center.x - size.length()/5, center.y + (size.length())/6, center.z - size.length()/5);
          controls.target.copy(center);
          controls.update();
            
          const boxHelper = new THREE.BoxHelper(He_mass_group, 0x888888);
          scene.add(boxHelper);

          const min = box.min;
          const max = box.max;
          const offset = size.length() * 0.1;

          const labelX = createAxisLabelMesh('Galactic Z', new THREE.Vector3(min.x + offset, min.y, min.z), new THREE.Euler(0, 0, 0));
          const labelY = createAxisLabelMesh('Galactic Y', new THREE.Vector3(min.x, min.y + offset, min.z), new THREE.Euler(0, 0, Math.PI / 2));
          const labelZ = createAxisLabelMesh('Galactic X', new THREE.Vector3(min.x, min.y, min.z + offset), new THREE.Euler( 0,  - Math.PI / 2, 0));        
              
          const labelScale = size.length() * 0.002; // 20% of diagonal length
          labelX.scale.set(labelScale, labelScale * 0.5, 1);
          labelY.scale.set(labelScale, labelScale * 0.5, 1);
          labelZ.scale.set(labelScale, labelScale * 0.5, 1);
    
          scene.add(labelX, labelY, labelZ);
          
          const arrowLength = size.length() * 0.2;
          const arrowX = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0), // direction: +X
            box.min,                    // origin: bounding box corner
            arrowLength,
            0xff4444                    // red
          );
          
          const arrowY = new THREE.ArrowHelper(
            new THREE.Vector3(0, 1, 0), // direction: +Y
            box.min,
            arrowLength,
            0x44ff44                    // green
          );
          
          const arrowZ = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1), // direction: +Z
            box.min,
            arrowLength,
            0x4444ff                    // blue
          );
          
          scene.add(arrowX, arrowY, arrowZ);

    // add the galactic plane image 
          const width = 90000;   // X span
          const height = 90000;  // Z span
          
          const groundGeometry = new THREE.PlaneGeometry(width, height, 1, 1);
          
          // Load texture
          const textureLoader = new THREE.TextureLoader();
          const groundTexture = textureLoader.load('https://precambrianmollusc.github.io/Glaxy_vis_test/gamegalaxy-4500px.png');
          
          // Material
          const groundMaterial = new THREE.MeshBasicMaterial({
            map: groundTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide
          });
          
          // Mesh
          const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
          
          // Rotate flat on XZ
          groundPlane.rotation.x = -Math.PI / 2;
          groundPlane.rotation.z = -Math.PI / 2;
          // Position at the rectangleâ€™s center
          groundPlane.position.set(25000, -5000, 0);
          
          scene.add(groundPlane);    


    
function updateVisibility() {
  Object.keys(subgroupStates).forEach(groupName => {
    const enabled = !!subgroupStates[groupName];
    (beforeMeshes[groupName] || []).forEach(m => { 
      if (m) m.visible = (activeState === 'before' && enabled); 
    });
    (afterMeshes[groupName]  || []).forEach(m => { 
      if (m) m.visible = (activeState === 'after'  && enabled); 
    });

    // ðŸ”§ If we have a real Three.js group, toggle it
    if (groupObjects[groupName]) {
      groupObjects[groupName].visible = enabled;
    }
  });
}


  // reusable toggle builder. If isMaster is true, checkbox flips before/after; otherwise it's a subgroup toggle.
  function addGroupToggle(groupArray, labelText, isMaster = false, groupKey = null) {
    const label = document.createElement('label');
    label.style.display = 'block';
    label.style.marginTop = '8px';
  
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.style.marginRight = '6px';
  
    if (isMaster) {
      // master visual match: checked => before, unchecked => after
      checkbox.checked = (activeState === 'before');
      checkbox.addEventListener('change', (e) => {
        activeState = e.target.checked ? 'before' : 'after';
        updateVisibility();
      });
    } else {
      const key = groupKey || labelText.replace(/\s+/g, '');
      subgroupStates[key] = subgroupStates[key] ?? true;
      checkbox.checked = !!subgroupStates[key];
      checkbox.addEventListener('change', (e) => {
        subgroupStates[key] = e.target.checked;
        updateVisibility();
      });
    }
  
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(labelText));
    ui.appendChild(label);
  }
    
        // master toggle (looks same as other checkboxes)
        //addGroupToggle(null, 'Show Before State', true);
        
        // subgroup toggles that control both before/after groups

        //addGroupToggle(beforeMeshes.PodSystems.concat(afterMeshes.PodSystems), 'Pod Systems', false, 'PodSystems');
       // addGroupToggle(He_mass_group, 'Helium % Show');

        // initialize visibility once
        updateVisibility();
        
      const bboxLabel = document.createElement('label');
      bboxLabel.style.display = 'block';
      bboxLabel.style.marginTop = '10px';
      
      const bboxCheckbox = document.createElement('input');
      bboxCheckbox.type = 'checkbox';
      bboxCheckbox.checked = true;
      bboxCheckbox.style.marginRight = '6px';
      
      bboxCheckbox.addEventListener('change', () => {
        const visible = bboxCheckbox.checked;
        boxHelper.visible = visible;
        labelX.visible = visible;
        labelY.visible = visible;
        labelZ.visible = visible;
        console.log('Bounding box and labels visibility set to', visible);
      });
      
      bboxLabel.appendChild(bboxCheckbox);
      bboxLabel.appendChild(document.createTextNode('Show Bounding Box & Labels'));
      ui.appendChild(bboxLabel);
              
    // Opacity slider for sphere mesh
    const opacityLabel = document.createElement('label');
    opacityLabel.style.display = 'block';
    opacityLabel.style.marginTop = '10px';
    opacityLabel.textContent = 'Hen Nebula Opacity';
    
    const opacitySlider = document.createElement('input');
    opacitySlider.type = 'range';
    opacitySlider.min = '0';
    opacitySlider.max = '1';
    opacitySlider.step = '0.01';
    opacitySlider.value = '0.3';
    
    opacitySlider.addEventListener('input', () => {
    const value = parseFloat(opacitySlider.value);

  // think this was a check if the sphere hadn't loaded but probbaly not needed    
  if (sphereMesh && sphereMesh.material) {
    const materials = Array.isArray(sphereMesh.material) ? sphereMesh.material : [sphereMesh.material];
    materials.forEach(mat => {
      mat.transparent = true;
      mat.opacity = value;
      mat.depthWrite = false;
      mat.needsUpdate = true;
    });
      } else {
        console.warn('Sphere mesh not yet available');
      }
    });
  
    //ui.appendChild(opacityLabel);
    //ui.appendChild(opacitySlider);

    
// Opacity slider for He_mass_group
const heOpacityLabel = document.createElement('label');
heOpacityLabel.style.display = 'block';
heOpacityLabel.style.marginTop = '10px';
heOpacityLabel.textContent = 'Helium %  Opacity';

const heOpacitySlider = document.createElement('input');
heOpacitySlider.type = 'range';
heOpacitySlider.min = '0';
heOpacitySlider.max = '1';
heOpacitySlider.step = '0.01';
heOpacitySlider.value = '1'; // start fully opaque

ui.appendChild(heOpacityLabel);
ui.appendChild(heOpacitySlider);

// Helper to apply opacity to the group
function setGroupOpacity(group, value) {
  group.traverse(obj => {
    if (obj.isMesh && obj.material) {
      const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
      mats.forEach(mat => {
        mat.transparent = true;
        mat.opacity = value;
        mat.depthWrite = false; // avoids zâ€‘fighting with transparency
        mat.needsUpdate = true;
      });
    }
  });
}

// Apply initial opacity
setGroupOpacity(He_mass_group, parseFloat(heOpacitySlider.value));
   

// Update on slider input
heOpacitySlider.addEventListener('input', () => {
  const value = parseFloat(heOpacitySlider.value);
  setGroupOpacity(He_mass_group, value);
});

    
function adjustVertexColors(obj, factor) {
  const colors = obj.geometry.attributes.color;
  const orig = obj.userData.originalColors;

  // factor = 1 â†’ original colors
  // factor = 2 â†’ halfway to pure red/blue
  // factor = 3 â†’ even closer to pure red/blue
  const t = factor - 1; // interpolation amount

  for (let i = 0; i < colors.count; i++) {
    let r = orig[i*3];
    let g = orig[i*3+1];
    let b = orig[i*3+2];

    if (r > b) {
      // Red side â†’ lerp toward pure bright red
      r = THREE.MathUtils.lerp(r, 1.0, t);
      g = THREE.MathUtils.lerp(g, 0.0, t);
      b = THREE.MathUtils.lerp(b, 0.0, t);
    } else if (b > r) {
      // Blue side â†’ lerp toward pure bright blue
      r = THREE.MathUtils.lerp(r, 0.0, t);
      g = THREE.MathUtils.lerp(g, 0.0, t);
      b = THREE.MathUtils.lerp(b, 1.0, t);
    }
    // If r â‰ˆ b (white/neutral), leave unchanged

    colors.setXYZ(i, r, g, b);
  }

  colors.needsUpdate = true;
}


    
// Label
const heIntensityLabel = document.createElement('label');
heIntensityLabel.style.display = 'block';
heIntensityLabel.style.marginTop = '10px';
heIntensityLabel.textContent = 'Helium % Intensity';

// Slider
const heIntensitySlider = document.createElement('input');
heIntensitySlider.type = 'range';
heIntensitySlider.min = '1.0';   // baseline = original colormap
heIntensitySlider.max = '2.0';   // pull strongly toward pure red/blue
heIntensitySlider.step = '0.1';  // smooth increments
heIntensitySlider.value = '1.0'; // start at original


heIntensitySlider.addEventListener('input', () => {
  const factor = parseFloat(heIntensitySlider.value);
  He_mass_group.traverse(obj => {
    if (obj.isMesh && obj.geometry && obj.geometry.attributes.color && obj.userData.originalColors) {
      adjustVertexColors(obj, factor);
    }
  });
});


// Add to UI
ui.appendChild(heIntensityLabel);
ui.appendChild(heIntensitySlider);

    
// Opacity slider for ground plane
const groundOpacityLabel = document.createElement('label');
groundOpacityLabel.style.display = 'block';
groundOpacityLabel.style.marginTop = '10px';
groundOpacityLabel.textContent = 'Galaxy Map Opacity -';

const groundOpacitySlider = document.createElement('input');
groundOpacitySlider.type = 'range';
groundOpacitySlider.min = '0';
groundOpacitySlider.max = '1';
groundOpacitySlider.step = '0.01';
groundOpacitySlider.value = '0.3';

// Apply initial opacity to match slider
groundPlane.material.opacity = parseFloat(groundOpacitySlider.value);
groundPlane.material.transparent = true; // ensure transparency is enabled
    
groundOpacitySlider.addEventListener('input', () => {
  groundPlane.material.opacity = parseFloat(groundOpacitySlider.value);
});

// Visibility toggle
const groundToggle = document.createElement('input');
groundToggle.type = 'checkbox';
groundToggle.checked = true;
groundToggle.addEventListener('change', () => {
  groundPlane.visible = groundToggle.checked;
});

// Yâ€‘position slider
const groundYLabel = document.createElement('label');
groundYLabel.style.display = 'block';
groundYLabel.textContent = 'Galaxy Map Y Position';

const groundYSlider = document.createElement('input');
groundYSlider.type = 'range';
groundYSlider.min = '-20000';
groundYSlider.max = '20000';
groundYSlider.step = '20';
groundYSlider.value = '-5000';

groundYSlider.addEventListener('input', () => {
  groundPlane.position.y = parseFloat(groundYSlider.value);
});



// Add to DOM
ui.appendChild(groundOpacityLabel);
ui.appendChild(groundOpacitySlider);
ui.appendChild(groundToggle);
ui.appendChild(groundYLabel);
ui.appendChild(groundYSlider);

// --- Midpoint slider ---
const sliceMidLabel = document.createElement('label');
sliceMidLabel.style.display = 'block';
sliceMidLabel.style.marginTop = '10px';
sliceMidLabel.textContent = 'Slice Midpoint (Y)';

const sliceMidSlider = document.createElement('input');
sliceMidSlider.type = 'range';
sliceMidSlider.min = '-3000';
sliceMidSlider.max = '3000';
sliceMidSlider.step = '320';
sliceMidSlider.value = '0';

// --- Thickness slider ---
const sliceThickLabel = document.createElement('label');
sliceThickLabel.style.display = 'block';
sliceThickLabel.style.marginTop = '10px';
sliceThickLabel.textContent = 'Slice Thickness';

const sliceThickSlider = document.createElement('input');
sliceThickSlider.type = 'range';
sliceThickSlider.min = '10';
sliceThickSlider.max = '10000';
sliceThickSlider.step = '100';
sliceThickSlider.value = '2480';

// --- Readout for min/max ---
const sliceReadout = document.createElement('div');
sliceReadout.style.marginTop = '5px';
sliceReadout.style.fontSize = '12px';
sliceReadout.style.color = '#FFD700';

// --- Define clipping planes once ---
const clipPlanes = [
  new THREE.Plane(new THREE.Vector3(0, 1, 0), 0),   // minY plane
  new THREE.Plane(new THREE.Vector3(0, -1, 0), 0)   // maxY plane
];

renderer.localClippingEnabled = true;

// Attach clipping planes to all meshes in the group
He_mass_group.traverse(obj => {
  if (obj.isMesh) {
    obj.material.clippingPlanes = clipPlanes;
    obj.material.clipShadows = true;
  }
});

// --- Update function ---
function updateSlice() {
  const mid = parseFloat(sliceMidSlider.value);
  const half = parseFloat(sliceThickSlider.value) / 2;

  const minY = mid - half;
  const maxY = mid + half;

  // Update readout
  sliceReadout.textContent = `Slice range: ${minY} â†’ ${maxY}`;

  // Update clipping planes
  clipPlanes[0].constant = -minY; // plane equation offset
  clipPlanes[1].constant = maxY;
}

// Hook up events
sliceMidSlider.addEventListener('input', updateSlice);
sliceThickSlider.addEventListener('input', updateSlice);

// Add to UI
ui.appendChild(sliceMidLabel);
ui.appendChild(sliceMidSlider);
ui.appendChild(sliceThickLabel);
ui.appendChild(sliceThickSlider);
ui.appendChild(sliceReadout);

// Initial update with presets
updateSlice();
    

function addTitleAndCreditsUI(initialTitle = 'Galactic Helium levels', initialCredits = `Squadron Leader: Urania Minora
CMDRs: 
IGAU Squadron
Contains Guardian Ruins Structures & Beacons 
He Overlay 
red > galactic average 
blue < galactic average 
opacity and color normailsed kullback Leibler divergence from the galactic average 
Calculated by mass code boxel 
Credits: 
Data from CMDR Orvidius https://edastro.com/mapcharts/
Spansh, EDGALAXYdata.space
everyone who contributes data to the feed`) {
  const metaWrap = document.createElement('div');
  metaWrap.style.marginTop = '12px';
  metaWrap.style.paddingTop = '8px';
  metaWrap.style.borderTop = '1px solid rgba(255,255,255,0.08)';
  metaWrap.style.fontSize = '13px';
  metaWrap.id = 'metaWrap';

  const titleLabel = document.createElement('label');
  titleLabel.style.display = 'block';
  titleLabel.style.marginBottom = '6px';
  titleLabel.style.fontWeight = '600';
  titleLabel.textContent = 'IGAU Survey project';
  metaWrap.appendChild(titleLabel);

  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.value = initialTitle;
  titleInput.style.width = '220px';
  titleInput.style.display = 'block';
  titleInput.style.marginBottom = '10px';
  titleInput.style.padding = '6px';
  titleInput.style.background = 'rgba(255,255,255,0.04)';
  titleInput.style.color = 'white';
  titleInput.style.border = '1px solid rgba(255,255,255,0.08)';
  titleInput.style.borderRadius = '3px';
  titleInput.id = 'vizTitleInput';
  metaWrap.appendChild(titleInput);

  const creditsLabel = document.createElement('label');
  creditsLabel.style.display = 'block';
  creditsLabel.style.marginBottom = '6px';
  creditsLabel.style.fontWeight = '600';
  creditsLabel.textContent = 'Credits and Data Contributors';
  metaWrap.appendChild(creditsLabel);

  const creditsArea = document.createElement('textarea');
  creditsArea.value = initialCredits;
  creditsArea.rows = 20;
  creditsArea.style.width = '220px';
  creditsArea.style.padding = '6px';
  creditsArea.style.background = 'rgba(255,255,255,0.04)';
  creditsArea.style.color = 'white';
  creditsArea.style.border = '1px solid rgba(255,255,255,0.08)';
  creditsArea.style.borderRadius = '3px';
  creditsArea.style.resize = 'vertical';
  creditsArea.id = 'vizCreditsArea';
  metaWrap.appendChild(creditsArea);

  const btn = document.createElement('button');
  btn.textContent = 'Hide Info';
  btn.style.display = 'block';
  btn.style.marginTop = '8px';
  btn.style.padding = '6px 8px';
  btn.style.background = 'rgba(255,255,255,0.06)';
  btn.style.color = 'white';
  btn.style.border = '1px solid rgba(255,255,255,0.12)';
  btn.style.borderRadius = '3px';
  btn.id = 'metaToggleBtn';
  metaWrap.appendChild(btn);

  const preview = document.createElement('div');
  preview.style.marginTop = '8px';
  preview.style.fontSize = '14px';
  preview.style.fontWeight = '600';
  preview.style.display = 'none';
  preview.style.whiteSpace = 'pre-wrap';
  preview.id = 'metaPreview';
  metaWrap.appendChild(preview);

  ui.appendChild(metaWrap);

  function updatePreview() {
    const title = titleInput.value.trim() || 'Untitled Visualization';
    const credits = creditsArea.value.trim();
    preview.textContent = `${title}\n\n${credits}`;
  }

  btn.addEventListener('click', () => {
    const hidden = titleInput.style.display === 'none';
    if (hidden) {
      titleInput.style.display = 'block';
      creditsArea.style.display = 'block';
      preview.style.display = 'none';
      btn.textContent = 'Hide Info';
    } else {
      titleInput.style.display = 'none';
      creditsArea.style.display = 'none';
      preview.style.display = 'block';
      btn.textContent = 'Show Info';
      updatePreview();
    }
  });

  titleInput.addEventListener('input', updatePreview);
  creditsArea.addEventListener('input', updatePreview);
  updatePreview();

  return { metaWrap, titleInput, creditsArea, btn, preview };
}

// Usage (call after ui exists, e.g., inside buildUIAndInit)
const metaControls = addTitleAndCreditsUI();


    
}); // â† closes loader.load

const scale = 45000 / 32000; // same as Python
const center = new THREE.Vector3(15918, -91, -1299); // from Python
  
loader.load('https://precambrianmollusc.github.io/Glaxy_vis_test/star_cloud.glb', gltf => {
  const cloud = gltf.scene;
 console.log('GLTF loaded-: ', cloud);
  cloud.traverse(obj => {
    console.log('Object:', obj);

    if (obj.isMesh) {
      console.log('Found mesh:', obj);

      const mat = obj.material;
      console.log('Material type:', mat.type);

      mat.color.set(0xffa500);
      mat.transparent = true;
      mat.opacity = 0.3;

      if ('size' in mat) {
        mat.size = 0.5;
      }

      mat.needsUpdate = true;
    }
  });

  cloud.traverse(obj => {
    if (obj.isPoints) {
      const mat = obj.material;

      mat.color.set(0xffa500);       // orange
      mat.transparent = true;
      mat.opacity = 0.03;              // low opacity
      mat.size = 0.15;                 // small point size
      mat.depthWrite = false;        // optional: improves blending

      mat.needsUpdate = true;
    }
  });
  
  //cloud.traverse(obj => {
  //  if (obj.isPoints) {
  //    obj.scale.setScalar(scale);      // uniform rescale
  //    obj.position.copy(center);       // recenter
  //  }
  //});

  scene.add(cloud);
});

 

const info = document.createElement('div');
info.style.position = 'absolute';
info.style.top = '10px';
info.style.left = '10px';
info.style.color = 'white';
info.style.fontFamily = 'monospace';
document.body.appendChild(info);

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  const pos = camera.position;
  const tgt = controls.target;
  info.textContent =
    `Camera: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) ` +
    `Target: (${tgt.x.toFixed(1)}, ${tgt.y.toFixed(1)}, ${tgt.z.toFixed(1)})`;

  renderer.render(scene, camera);
}

    
//  function animate() {
//    requestAnimationFrame(animate);
//    controls.update();
//    renderer.render(scene, camera);
//    //labelX.lookAt(camera.position);
//    //labelY.lookAt(camera.position);
//    //labelZ.lookAt(camera.position);
//  }

  animate();
  
  
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
